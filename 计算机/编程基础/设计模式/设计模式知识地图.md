## 1️⃣ 基础概念

|分类|内容|
|---|---|
|**定义**|可重用、可维护的软件设计方案|
|**目的**|提高代码可复用性、可扩展性、可维护性|
|**特点**|名称、问题、解决方案、效果|
|**设计原则**|单一职责原则、开闭原则、里氏替换原则、依赖倒置原则、接口隔离原则、合成复用原则|
|**分类标准**|创建型、结构型、行为型|

---

## 2️⃣ 创建型模式

|模式|核心思想|应用场景|
|---|---|---|
|**单例模式 (Singleton)**|保证类只有一个实例|配置管理器、线程池、日志|
|**工厂方法模式 (Factory Method)**|提供创建对象接口，由子类决定实例|日志、数据库驱动、UI控件|
|**抽象工厂模式 (Abstract Factory)**|提供一组相关对象的接口|UI风格切换、多数据库支持|
|**建造者模式 (Builder)**|将复杂对象的构建与表示分离|复杂对象构造，如文本解析器、产品配置|
|**原型模式 (Prototype)**|通过克隆已有对象创建新对象|对象创建成本高、需要复制|

---

## 3️⃣ 结构型模式

|模式|核心思想|应用场景|
|---|---|---|
|**适配器模式 (Adapter)**|将接口转换为客户端所期望的接口|第三方库适配、旧接口兼容|
|**桥接模式 (Bridge)**|抽象与实现分离|图形绘制API、设备驱动|
|**组合模式 (Composite)**|树形结构表示整体-部分关系|文件系统、UI组件树|
|**装饰器模式 (Decorator)**|动态扩展对象功能|日志、流处理、UI装饰|
|**外观模式 (Facade)**|提供统一接口，简化复杂系统|系统集成、API封装|
|**享元模式 (Flyweight)**|共享对象以减少内存|文本编辑器字符对象、图形对象|
|**代理模式 (Proxy)**|为对象提供代理以控制访问|远程代理、虚拟代理、保护代理|

---

## 4️⃣ 行为型模式

|模式|核心思想|应用场景|
|---|---|---|
|**责任链模式 (Chain of Responsibility)**|将请求沿链传递|事件处理、请求过滤|
|**命令模式 (Command)**|将请求封装为对象|Undo/Redo、任务队列|
|**解释器模式 (Interpreter)**|给语言定义文法，并解释执行|正则、DSL解释器|
|**迭代器模式 (Iterator)**|提供统一遍历方式|集合遍历、数据结构|
|**中介者模式 (Mediator)**|用一个对象封装对象交互|聊天室、UI组件交互|
|**备忘录模式 (Memento)**|保存和恢复对象状态|撤销操作、状态回滚|
|**观察者模式 (Observer)**|定义对象间的一对多依赖|事件监听、消息推送|
|**状态模式 (State)**|对象状态改变行为改变|状态机、游戏角色|
|**策略模式 (Strategy)**|定义一系列算法，封装后可互换|排序、支付方式、优惠计算|
|**模板方法模式 (Template Method)**|定义算法骨架，子类实现细节|数据处理流程、UI模板|
|**访问者模式 (Visitor)**|封装作用于对象的操作|数据结构遍历、报表生成|

---

## 5️⃣ 设计模式使用原则

|原则|解释|
|---|---|
|**单一职责原则 (SRP)**|一个类只负责一件事|
|**开闭原则 (OCP)**|对扩展开放，对修改关闭|
|**里氏替换原则 (LSP)**|子类可以替换父类|
|**依赖倒置原则 (DIP)**|依赖抽象，不依赖具体实现|
|**接口隔离原则 (ISP)**|接口尽量小、专一|
|**合成复用原则 (CRP)**|优先使用组合而非继承|

---

## 6️⃣ 高级与实践

|分类|内容|
|---|---|
|**模式组合**|多个模式组合使用，解决复杂场景|
|**框架设计模式**|Spring IoC/DI、React组件模式、Redux|
|**重构与模式**|代码重构过程中应用模式|
|**性能与模式**|Flyweight减少内存、Proxy控制访问|